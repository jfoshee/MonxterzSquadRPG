@page "/"
@inject NavigationManager navigationManager;
@inject IChangeUserService changeUserService;
@inject IGameStateClient gameStateClient;
@inject IGameTestHarness game;

<PageTitle>Monxterz Squad RPG</PageTitle>

<h1>Hello, @playerName!</h1>

<div class="container">
    <div class="row">
        <div class="col">
            Attacker:
            @if (selectedFriendly is not null)
            {
                <a href="" @onclick="ShowRenameDialog">
                    @selectedFriendly.DisplayName
                </a>
                <span class="mx-1">
                    @selectedFriendly.Stats
                </span>
                <button class="btn btn-outline-secondary btn-sm mx-3" title="Strength Training" @onclick="StartTraining">
                    <span class="oi oi-expand-up"></span>
                </button>
            }
        </div>
        <div class="col">
            Defender: @selectedEnemy?.DisplayName @selectedEnemy?.Stats
        </div>
    </div>
    <div class="row">
        <div class="col">
            <button type="button" class="btn btn-danger" @onclick="Attack" disabled="@(!CanAttack)">
                Attack!
            </button>
        </div>
    </div>
    <div class="row align-items-top mt-2">
        <div class="col">
            <h3>
                Your Characters
                <button type="button" class="btn btn-success" title="New Character" @onclick="NewCharacter">
                    <span class="oi oi-plus"></span>
                </button>
            </h3>
            <div class="list-group">
                @foreach (var character in friendlies)
                {
                    <button type="button" class="list-group-item list-group-item-action @active(character)" @onclick="() => selectedFriendly = character">
                        @character.DisplayName @character.Stats
                        @if (character.IsTraining)
                        {
                            <div class="spinner-grow spinner-grow-sm float-end" role="status"></div>
                        }
                    </button>
                }
            </div>
        </div>
        <div class="col">
            <h3>
                Enemies
            </h3>
            <div class="list-group">
                @foreach (var character in enemies)
                {
                    <button type="button" class="list-group-item list-group-item-action @active(character)" @onclick="() => selectedEnemy = character">
                        @character.DisplayName @character.Stats @character.Entity.SystemState.OwnerId
                    </button>
                }
            </div>
        </div>
    </div>
</div>

@if (showRenameDialog)
{
    <Dialog Title="Rename a Character" Message="New Character Name" OnClose="CloseRenameDialog" Text="@selectedFriendly?.DisplayName" OnSave="RenameCharacter" />
}

@code
{
    const int TrainingTime = 10;
    private string playerName = "...";
    List<CharacterViewModel> friendlies = new();
    List<CharacterViewModel> enemies = new();
    CharacterViewModel? selectedFriendly;
    CharacterViewModel? selectedEnemy;

    bool CanAttack => selectedEnemy is not null && selectedFriendly is not null && !selectedFriendly.IsTraining;

    protected override async Task OnParametersSetAsync()
    {
        if (changeUserService.CurrentUserId is null)
            navigationManager.NavigateTo("/login");
        else
        {
            await game.InitAsync();

            var user = await gameStateClient.GetUserAsync() ?? throw new Exception("Failed to fetch current user entity");
            playerName = user.DisplayName ?? user.Id ?? "??";

            var allNearbyEntities = await gameStateClient.GetEntitiesNearbyAsync();
            var allNearbyCharacters = allNearbyEntities!.Where(BattleClient.IsCharacter);
            friendlies = ToCharacterViewModels(allNearbyCharacters, e => e.SystemState.OwnerId == user.Id);
            enemies = ToCharacterViewModels(allNearbyCharacters, e => e.SystemState.OwnerId != user.Id);

            // HACK: Check training for any friendlies that are traning when the page loads
            Task.Delay(TrainingTime * 1000).ContinueWith(_ => {
                foreach(var friendly in friendlies)
                {
                    if (friendly.IsTraining)
                        CheckTraining(friendly);
                }
            });
        }
    }

    private async Task NewCharacter()
    {
        var character = await game.Create.Character();
        friendlies.Insert(0, new CharacterViewModel(character));
    }

    private async Task Attack()
    {
        if (selectedFriendly is null || selectedEnemy is null)
            return;
        await game.Call.Attack(selectedFriendly.Entity, selectedEnemy.Entity);
        // HACK: Refresh enemy in view
        var index = enemies.IndexOf(selectedEnemy);
        enemies[index] = selectedEnemy = new CharacterViewModel(selectedEnemy.Entity);
    }

    private List<CharacterViewModel> ToCharacterViewModels(IEnumerable<GameEntityState> entities, Func<GameEntityState, bool> predicate)
    {
        return entities.Where(predicate)
                       .Select(entity => new CharacterViewModel(entity))
                       .ToList();
    }

    string active(CharacterViewModel c)
    {
        return c == selectedEnemy || c == selectedFriendly ? "active" : "";
    }

    bool showRenameDialog = false;
    void CloseRenameDialog() => showRenameDialog = false;
    void ShowRenameDialog() => showRenameDialog = true;
    async Task RenameCharacter(string newDisplayName)
    {
        var updatedEntity = await gameStateClient.PutEntityDisplayNameAsync(selectedFriendly.Entity.Id, newDisplayName);
        selectedFriendly.Entity = updatedEntity;
    }

    async Task StartTraining()
    {
        var character = selectedFriendly!;
        await game.Call.Train(character.Entity, "strength", TrainingTime);
        // HACK: Background task to check training after it is completed
        Task.Delay(TrainingTime * 1000).ContinueWith(_ => CheckTraining(character));
    }

    async Task CheckTraining(CharacterViewModel character)
    {
        await game.Call.CheckTraining(character.Entity);
        base.StateHasChanged();
    }
}
