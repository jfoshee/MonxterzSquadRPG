@page "/"
@inject NavigationManager navigationManager;
@inject IChangeUserService changeUserService;
@inject IGameStateClient gameStateClient;
@inject IGameTestHarness game;
@inject IToastService toastService;
@inject ILocalStorageService localStorageService;
@inject IGameBearerTokenProvider gameTokenProvider;

<PageTitle>Monxterz Squad RPG</PageTitle>

<h1>Hello, @playerName!</h1>

<div class="container">
    <div class="row">
        <div class="col">
            Attacker:
            @if (selectedFriendly is not null)
            {
                <a href="" @onclick="ShowRenameDialog">
                    @selectedFriendly.DisplayName
                </a>
                <span class="mx-1">
                    @selectedFriendly.Stats
                </span>
                <button class="btn btn-outline-secondary btn-sm" title="Strength Training" @onclick="StartTraining" disabled="@(!CanTrain)">
                    <span class="oi oi-expand-up"></span>
                </button>
                <button class="btn btn-outline-secondary btn-sm" title="Refresh Status" @onclick="() => CheckStatus(selectedFriendly)">
                    <span class="oi oi-loop-circular"></span>
                </button>
                @if (selectedFriendly.IsTraining || selectedFriendly.IsRecovering)
                {
                    <div class="spinner-grow spinner-grow-sm float-end" role="status"></div>
                }
            }
        </div>
        <div class="col">
            Defender: @selectedEnemy?.DisplayName @selectedEnemy?.Stats
        </div>
    </div>
    <div class="row">
        <div class="col">
            <button type="button" class="btn btn-danger" @onclick="Attack" disabled="@(!CanAttack)">
                Attack!
            </button>
        </div>
    </div>
    <div class="row align-items-top mt-2">
        <div class="col">
            <h3>
                Your Characters
                <button type="button" class="btn btn-success" title="New Character" @onclick="NewCharacter">
                    <span class="oi oi-plus"></span>
                </button>
            </h3>
            <div class="list-group">
                @foreach (var character in friendlies)
                {
                    <button type="button" class="list-group-item list-group-item-action @active(character)" @onclick="() => selectedFriendly = character">
                        @character.DisplayName @character.Stats
                        @if (character.IsTraining || character.IsRecovering)
                        {
                            <div class="spinner-grow spinner-grow-sm float-end" role="status"></div>
                        }
                    </button>
                }
            </div>
        </div>
        <div class="col">
            <h3>
                Enemies
            </h3>
            <div class="list-group">
                @foreach (var character in enemies)
                {
                    <button type="button" class="list-group-item list-group-item-action @active(character)" @onclick="() => selectedEnemy = character">
                        @character.DisplayName @character.Stats @character.Entity.SystemState.OwnerId
                    </button>
                }
            </div>
        </div>
    </div>
</div>

@if (showRenameDialog)
{
    <Dialog Title="Rename a Character" Message="New Character Name" OnClose="CloseRenameDialog" Text="@selectedFriendly?.DisplayName" OnSave="RenameCharacter" />
}
<BlazoredToasts Position="ToastPosition.TopRight"
                Timeout="10"
                RemoveToastsOnNavigation="true"
                ShowProgressBar="true" />

@code
{
    const int TrainingTime = 10;
    const int RecoveryTime = 10 + 1; // Happens to match what is in Attack.js
    private string playerName = "...";
    List<CharacterViewModel> friendlies = new();
    List<CharacterViewModel> enemies = new();
    CharacterViewModel? selectedFriendly;
    CharacterViewModel? selectedEnemy;

    bool CanTrain => selectedFriendly is not null
                     && !selectedFriendly.IsTraining
                     && !selectedFriendly.IsRecovering;

    bool CanAttack => selectedEnemy is not null
                      && selectedFriendly is not null
                      && !selectedFriendly.IsTraining
                      && !selectedFriendly.IsRecovering;

    protected override async Task OnInitializedAsync()
    {
        var token = await localStorageService.GetItemAsync<string>("Token");
        var userId = await localStorageService.GetItemAsync<string>("UserID");
        // TODO: Break direct dependence on IGameBearerTokenProvider
        gameTokenProvider.SetBearerToken(userId, token);
    }

    protected override async Task OnParametersSetAsync()
    {
        if (changeUserService.CurrentUserId is null)
            navigationManager.NavigateTo("/login");
        else
        {
            await game.InitAsync();

            var user = await gameStateClient.GetUserAsync() ?? throw new Exception("Failed to fetch current user entity");
            playerName = user.DisplayName ?? user.Id ?? "??";

            var allNearbyEntities = await gameStateClient.GetEntitiesNearbyAsync();
            var allNearbyCharacters = allNearbyEntities!.Where(BattleClient.IsCharacter);
            friendlies = ToCharacterViewModels(allNearbyCharacters, e => e.SystemState.OwnerId == user.Id);
            enemies = ToCharacterViewModels(allNearbyCharacters, e => e.SystemState.OwnerId != user.Id);

            // HACK: Check training for any friendlies that are traning when the page loads
            Task.Delay(TrainingTime * 1000).ContinueWith(_ =>
            {
                foreach (var friendly in friendlies)
                {
                    if (friendly.IsTraining || friendly.IsRecovering)
                        CheckStatus(friendly);
                }
            });
        }
    }

    private async Task NewCharacter()
    {
        try
        {
            var character = await game.Create.Character();
            friendlies.Insert(0, new CharacterViewModel(character));
        }
        catch (ApiException apiException)
        {
            ShowError(apiException);
        }
    }

    private async Task Attack()
    {
        if (selectedFriendly is null || selectedEnemy is null)
            return;
        try
        {
            await game.Call.Attack(selectedFriendly.Entity, selectedEnemy.Entity);
            // HACK: Refresh enemy in view
            var index = enemies.IndexOf(selectedEnemy);
            enemies[index] = selectedEnemy = new CharacterViewModel(selectedEnemy.Entity);
            // HACK: Background task to check recovery after it is completed
            Task.Delay(RecoveryTime * 1000).ContinueWith(_ => CheckStatus(selectedFriendly));
        }
        catch (ApiException apiException)
        {
            ShowError(apiException);
        }
    }

    private List<CharacterViewModel> ToCharacterViewModels(IEnumerable<GameEntityState> entities, Func<GameEntityState, bool> predicate)
    {
        return entities.Where(predicate)
                       .Select(entity => new CharacterViewModel(entity))
                       .ToList();
    }

    string active(CharacterViewModel c)
    {
        return c == selectedEnemy || c == selectedFriendly ? "active" : "";
    }

    bool showRenameDialog = false;
    void CloseRenameDialog() => showRenameDialog = false;
    void ShowRenameDialog() => showRenameDialog = true;
    async Task RenameCharacter(string newDisplayName)
    {
        try
        {
            var updatedEntity = await gameStateClient.PutEntityDisplayNameAsync(selectedFriendly.Entity.Id, newDisplayName);
            selectedFriendly.Entity = updatedEntity;
        }
        catch (ApiException apiException)
        {
            ShowError(apiException);
        }
    }

    async Task StartTraining()
    {
        try
        {
            var character = selectedFriendly!;
            await game.Call.Train(character.Entity, "strength", TrainingTime);
            // HACK: Background task to check training after it is completed
            Task.Delay(TrainingTime * 1000).ContinueWith(_ => CheckStatus(character));
        }
        catch (ApiException apiException)
        {
            ShowError(apiException);
        }
    }

    async Task CheckStatus(CharacterViewModel character)
    {
        try
        {
            await game.Call.CheckStatus(character.Entity);
            base.StateHasChanged();
        }
        catch (ApiException apiException)
        {
            ShowError(apiException);
        }
    }

    private void ShowError(ApiException apiException)
    {
        toastService.ShowError(apiException.SimpleMessage());
    }
}
